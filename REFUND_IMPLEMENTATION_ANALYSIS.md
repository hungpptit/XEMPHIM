# üîç Ph√¢n t√≠ch kh·∫£ nƒÉng tri·ªÉn khai Refund Flow

**Ng√†y ph√¢n t√≠ch:** 23/10/2025  
**T√†i li·ªáu tham kh·∫£o:** `refund_flow.md`

---

## ‚úÖ T√ìM T·∫ÆT: C√ì TH·ªÇ TRI·ªÇN KHAI ƒê∆Ø·ª¢C

H·ªá th·ªëng hi·ªán t·∫°i **ƒë√£ c√≥ n·ªÅn t·∫£ng c∆° b·∫£n** ƒë·ªÉ h·ªó tr·ª£ refund flow, nh∆∞ng **c·∫ßn b·ªï sung th√™m:**
1. B·∫£ng `RefundRequests` (ch∆∞a c√≥)
2. B·∫£ng `UserBankAccounts` (ch∆∞a c√≥)
3. C√°c API endpoints m·ªõi cho refund workflow
4. C·∫≠p nh·∫≠t webhook server ƒë·ªÉ x·ª≠ l√Ω refund confirmation

---

## üìä 1. ƒê√ÅNH GI√Å DB HI·ªÜN T·∫†I

### ‚úÖ Nh·ªØng g√¨ ƒë√£ c√≥ (t·ª´ DB diagram):

| B·∫£ng | C·ªôt quan tr·ªçng | Tr·∫°ng th√°i |
|------|---------------|-----------|
| `bookings` | `id`, `user_id`, `showtime_id`, `booking_code`, `total_price`, `status` | ‚úÖ ƒê√£ c√≥ |
| `payments` | `id`, `booking_id`, `payment_method`, `amount`, `status`, `transaction_ref` | ‚úÖ ƒê√£ c√≥ |
| `users` | `id`, `full_name`, `email`, `phone_number`, `role` | ‚úÖ ƒê√£ c√≥ |
| `showtimes` | `id`, `movie_id`, `start_time`, `end_time` | ‚úÖ ƒê√£ c√≥ (ƒë·ªÉ check th·ªùi gian tr∆∞·ªõc gi·ªù chi·∫øu) |

### ‚ùå Nh·ªØng g√¨ c√≤n thi·∫øu:

#### 1. B·∫£ng `RefundRequests` (c·∫ßn t·∫°o m·ªõi)

```sql
CREATE TABLE refund_requests (
  id INT PRIMARY KEY IDENTITY(1,1),
  booking_id INT NOT NULL,
  user_id INT NOT NULL,
  refund_amount DECIMAL(10,2) NOT NULL,
  reason NVARCHAR(500),
  status VARCHAR(20) NOT NULL DEFAULT 'pending',  -- pending, approved, done, rejected
  external_ref VARCHAR(100),  -- reference_number t·ª´ SePay webhook
  qr_url NVARCHAR(500),
  created_at DATETIME DEFAULT GETUTCDATE(),
  processed_at DATETIME,
  FOREIGN KEY (booking_id) REFERENCES bookings(id),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Index ƒë·ªÉ t√¨m nhanh
CREATE INDEX idx_refund_booking ON refund_requests(booking_id);
CREATE INDEX idx_refund_status ON refund_requests(status);
```

#### 2. B·∫£ng `UserBankAccounts` (c·∫ßn t·∫°o m·ªõi)

```sql
CREATE TABLE user_bank_accounts (
  id INT PRIMARY KEY IDENTITY(1,1),
  user_id INT NOT NULL,
  bank_code VARCHAR(20) NOT NULL,  -- VCB, TPB, VTB, etc.
  account_number VARCHAR(50) NOT NULL,
  account_name NVARCHAR(100) NOT NULL,
  is_primary BIT DEFAULT 0,
  is_verified BIT DEFAULT 0,
  created_at DATETIME DEFAULT GETUTCDATE(),
  updated_at DATETIME DEFAULT GETUTCDATE(),
  FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Index
CREATE INDEX idx_bank_user ON user_bank_accounts(user_id);
```

**L∆∞u √Ω b·∫£o m·∫≠t:** N√™n m√£ h√≥a `account_number` b·∫±ng AES-256 ho·∫∑c l∆∞u qua service ri√™ng.

---

## üß© 2. ƒê√ÅNH GI√Å CODE BACKEND HI·ªÜN T·∫†I

### ‚úÖ Nh·ªØng g√¨ ƒë√£ c√≥:

#### A. Service `bookingService.js`
```javascript
// ƒê√£ c√≥ function refundBooking
export const refundBooking = async ({ booking_id, reason = null }) => {
  // ‚úÖ Ki·ªÉm tra booking.status === 'confirmed'
  // ‚úÖ T·∫°o Payment √¢m v·ªõi status='refunded'
  // ‚úÖ C·∫≠p nh·∫≠t Payments c≈© th√†nh 'refunded'
  // ‚úÖ C·∫≠p nh·∫≠t Bookings.status='refunded'
}
```

**V·∫•n ƒë·ªÅ:** Function n√†y l√† **refund tr·ª±c ti·∫øp**, kh√¥ng qua workflow ph√™ duy·ªát (pending ‚Üí approved ‚Üí done).

#### B. Controller & Route
```javascript
// backend/src/controllers/bookingController.js
export const refundBookingHandler = async (req, res) => { ... }

// backend/src/routes/bookingRoutes.js
router.post('/:bookingId/refund', bookingController.refundBookingHandler);
```

**Endpoint hi·ªán t·∫°i:** `POST /api/bookings/:bookingId/refund`  
‚Üí Refund ngay l·∫≠p t·ª©c, kh√¥ng c√≥ b∆∞·ªõc "user request ‚Üí admin approve ‚Üí payment".

---

### ‚ùå Nh·ªØng g√¨ c·∫ßn b·ªï sung:

#### 1. Model `RefundRequest`
T·∫°o file `backend/src/models/refund_request.js`:

```javascript
export default (sequelize, DataTypes) => {
  const RefundRequest = sequelize.define('RefundRequest', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    booking_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    refund_amount: {
      type: DataTypes.DECIMAL(10, 2),
      allowNull: false
    },
    reason: {
      type: DataTypes.STRING(500)
    },
    status: {
      type: DataTypes.STRING(20),
      allowNull: false,
      defaultValue: 'pending'
    },
    external_ref: {
      type: DataTypes.STRING(100)
    },
    qr_url: {
      type: DataTypes.STRING(500)
    },
    created_at: {
      type: DataTypes.DATE
    },
    processed_at: {
      type: DataTypes.DATE
    }
  }, {
    tableName: 'refund_requests',
    timestamps: false
  });

  return RefundRequest;
};
```

#### 2. Model `UserBankAccount`
T·∫°o file `backend/src/models/user_bank_account.js`:

```javascript
export default (sequelize, DataTypes) => {
  const UserBankAccount = sequelize.define('UserBankAccount', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    user_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    bank_code: {
      type: DataTypes.STRING(20),
      allowNull: false
    },
    account_number: {
      type: DataTypes.STRING(50),
      allowNull: false
    },
    account_name: {
      type: DataTypes.STRING(100),
      allowNull: false
    },
    is_primary: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    is_verified: {
      type: DataTypes.BOOLEAN,
      defaultValue: false
    },
    created_at: {
      type: DataTypes.DATE
    },
    updated_at: {
      type: DataTypes.DATE
    }
  }, {
    tableName: 'user_bank_accounts',
    timestamps: false
  });

  return UserBankAccount;
};
```

#### 3. Service `refundService.js` (m·ªõi)

T·∫°o file `backend/src/services/refundService.js`:

```javascript
import { RefundRequest, Booking, Payment, UserBankAccount, Showtime, sequelize } from '../models/index.js';
import { v4 as uuidv4 } from 'uuid';

// 1. User t·∫°o y√™u c·∫ßu ho√†n ti·ªÅn
export const createRefundRequest = async ({ booking_id, user_id, reason }) => {
  const t = await sequelize.transaction();
  try {
    // Ki·ªÉm tra booking
    const booking = await Booking.findByPk(booking_id, {
      include: [{ model: Showtime }],
      transaction: t
    });
    
    if (!booking) {
      await t.rollback();
      return { success: false, message: 'Booking not found' };
    }

    if (booking.status !== 'confirmed') {
      await t.rollback();
      return { success: false, message: 'Only confirmed bookings can be refunded' };
    }

    // Ki·ªÉm tra th·ªùi gian (90 ph√∫t tr∆∞·ªõc gi·ªù chi·∫øu)
    const now = new Date();
    const showtimeStart = new Date(booking.Showtime.start_time);
    const minutesUntilShow = (showtimeStart - now) / (1000 * 60);
    
    if (minutesUntilShow < 90) {
      await t.rollback();
      return { success: false, message: 'Cannot refund within 90 minutes of showtime' };
    }

    // Ki·ªÉm tra ƒë√£ c√≥ refund request ch∆∞a
    const existingRefund = await RefundRequest.findOne({
      where: { booking_id, status: ['pending', 'approved'] },
      transaction: t
    });

    if (existingRefund) {
      await t.rollback();
      return { success: false, message: 'Refund request already exists for this booking' };
    }

    // T·∫°o refund request
    const refundRequest = await RefundRequest.create({
      booking_id,
      user_id,
      refund_amount: booking.total_price,
      reason,
      status: 'pending',
      created_at: new Date()
    }, { transaction: t });

    await t.commit();
    return { success: true, refundRequest: refundRequest.toJSON() };
  } catch (err) {
    await t.rollback();
    throw err;
  }
};

// 2. Admin l·∫•y danh s√°ch refund requests
export const getRefundRequests = async ({ status = null, limit = 50 }) => {
  const where = status ? { status } : {};
  
  const requests = await RefundRequest.findAll({
    where,
    include: [
      { model: Booking, attributes: ['id', 'booking_code', 'total_price', 'status'] },
      { model: User, attributes: ['id', 'full_name', 'email', 'phone_number'] }
    ],
    order: [['created_at', 'DESC']],
    limit
  });

  return requests;
};

// 3. Admin sinh QR refund
export const generateRefundQR = async ({ refund_id }) => {
  const t = await sequelize.transaction();
  try {
    const refundRequest = await RefundRequest.findByPk(refund_id, {
      include: [{ model: Booking }],
      transaction: t
    });

    if (!refundRequest) {
      await t.rollback();
      return { success: false, message: 'Refund request not found' };
    }

    if (refundRequest.status !== 'pending') {
      await t.rollback();
      return { success: false, message: 'Refund request already processed' };
    }

    // L·∫•y th√¥ng tin STK user
    const userBank = await UserBankAccount.findOne({
      where: { user_id: refundRequest.user_id, is_primary: true },
      transaction: t
    });

    if (!userBank) {
      await t.rollback();
      return { success: false, message: 'User bank account not found. User needs to add bank info.' };
    }

    // Sinh QR URL
    const amount = Number(refundRequest.refund_amount);
    const addInfo = `HT-BOOK${refundRequest.booking_id}-${refundRequest.Booking.booking_code}`;
    const qrUrl = `https://img.vietqr.io/image/${userBank.bank_code}-${userBank.account_number}-compact2.jpg?amount=${amount}&addInfo=${encodeURIComponent(addInfo)}`;

    // C·∫≠p nh·∫≠t refund request
    refundRequest.qr_url = qrUrl;
    refundRequest.status = 'approved';
    await refundRequest.save({ transaction: t });

    await t.commit();
    return { 
      success: true, 
      qr_url: qrUrl,
      refundRequest: refundRequest.toJSON(),
      bankAccount: {
        bank_code: userBank.bank_code,
        account_number: userBank.account_number,
        account_name: userBank.account_name
      }
    };
  } catch (err) {
    await t.rollback();
    throw err;
  }
};

// 4. Webhook x√°c nh·∫≠n refund ƒë√£ chuy·ªÉn ti·ªÅn
export const confirmRefund = async ({ bookingId, bookingCode, amount, reference, transactionDate }) => {
  const t = await sequelize.transaction();
  try {
    // T√¨m refund request
    const refundRequest = await RefundRequest.findOne({
      where: { 
        booking_id: bookingId,
        status: 'approved'
      },
      include: [{ model: Booking }],
      transaction: t,
      lock: t.LOCK.UPDATE
    });

    if (!refundRequest) {
      await t.rollback();
      return { success: false, message: 'Approved refund request not found for this booking' };
    }

    // Verify booking code
    if (refundRequest.Booking.booking_code !== bookingCode) {
      await t.rollback();
      return { success: false, message: 'Booking code mismatch' };
    }

    // Verify amount
    if (Math.abs(Number(amount) - Number(refundRequest.refund_amount)) > 0.01) {
      await t.rollback();
      return { success: false, message: 'Refund amount mismatch' };
    }

    // C·∫≠p nh·∫≠t refund request
    refundRequest.status = 'done';
    refundRequest.external_ref = reference;
    refundRequest.processed_at = new Date(transactionDate);
    await refundRequest.save({ transaction: t });

    // T·∫°o Payment √¢m
    await Payment.create({
      booking_id: bookingId,
      payment_method: 'refund',
      payment_code: `REFUND-${uuidv4()}`,
      amount: -Number(amount),
      status: 'refunded',
      transaction_ref: reference,
      created_at: new Date(transactionDate)
    }, { transaction: t });

    // C·∫≠p nh·∫≠t Payments c≈©
    await Payment.update(
      { status: 'refunded' },
      { where: { booking_id: bookingId, status: 'paid' }, transaction: t }
    );

    // C·∫≠p nh·∫≠t Booking
    await Booking.update(
      { status: 'refunded' },
      { where: { id: bookingId }, transaction: t }
    );

    await t.commit();
    return { success: true, message: 'Refund confirmed successfully', refundRequest: refundRequest.toJSON() };
  } catch (err) {
    await t.rollback();
    throw err;
  }
};

export default {
  createRefundRequest,
  getRefundRequests,
  generateRefundQR,
  confirmRefund
};
```

#### 4. Controller `refundController.js` (m·ªõi)

T·∫°o file `backend/src/controllers/refundController.js`:

```javascript
import refundService from '../services/refundService.js';

// POST /api/refunds - User t·∫°o y√™u c·∫ßu ho√†n ti·ªÅn
export const createRefundRequestHandler = async (req, res) => {
  try {
    const { bookingId, reason } = req.body;
    const userId = req.user?.id; // T·ª´ JWT middleware

    if (!userId) {
      return res.status(401).json({ message: 'Unauthorized' });
    }

    const result = await refundService.createRefundRequest({
      booking_id: bookingId,
      user_id: userId,
      reason
    });

    if (!result.success) {
      return res.status(400).json({ message: result.message });
    }

    res.status(201).json(result);
  } catch (err) {
    console.error('Error creating refund request:', err);
    res.status(500).json({ message: 'Internal server error' });
  }
};

// GET /api/refunds - Admin xem danh s√°ch
export const getRefundRequestsHandler = async (req, res) => {
  try {
    const { status, limit } = req.query;
    const requests = await refundService.getRefundRequests({ status, limit: Number(limit) || 50 });
    res.json({ refunds: requests });
  } catch (err) {
    console.error('Error getting refund requests:', err);
    res.status(500).json({ message: 'Internal server error' });
  }
};

// POST /api/refunds/:id/qr - Admin sinh QR
export const generateRefundQRHandler = async (req, res) => {
  try {
    const refundId = parseInt(req.params.id);
    const result = await refundService.generateRefundQR({ refund_id: refundId });

    if (!result.success) {
      return res.status(400).json({ message: result.message });
    }

    res.json(result);
  } catch (err) {
    console.error('Error generating refund QR:', err);
    res.status(500).json({ message: 'Internal server error' });
  }
};

// POST /api/refunds/confirm - Webhook callback
export const confirmRefundHandler = async (req, res) => {
  try {
    const { bookingId, bookingCode, amount, reference, transactionDate } = req.body;

    const result = await refundService.confirmRefund({
      bookingId,
      bookingCode,
      amount,
      reference,
      transactionDate
    });

    if (!result.success) {
      return res.status(400).json({ message: result.message });
    }

    res.json(result);
  } catch (err) {
    console.error('Error confirming refund:', err);
    res.status(500).json({ message: 'Internal server error' });
  }
};

export default {
  createRefundRequestHandler,
  getRefundRequestsHandler,
  generateRefundQRHandler,
  confirmRefundHandler
};
```

#### 5. Routes `refundRoutes.js` (m·ªõi)

T·∫°o file `backend/src/routes/refundRoutes.js`:

```javascript
import express from 'express';
import refundController from '../controllers/refundController.js';
// import { authenticateJWT, requireAdmin } from '../middlewares/auth.js'; // N·∫øu c√≥

const router = express.Router();

// User t·∫°o y√™u c·∫ßu ho√†n ti·ªÅn
router.post('/', refundController.createRefundRequestHandler);

// Admin xem danh s√°ch y√™u c·∫ßu
router.get('/', refundController.getRefundRequestsHandler);

// Admin sinh QR refund
router.post('/:id/qr', refundController.generateRefundQRHandler);

// Webhook callback t·ª´ SePay (via webhook server)
router.post('/confirm', refundController.confirmRefundHandler);

export default router;
```

ƒêƒÉng k√Ω route trong `backend/src/index.js`:

```javascript
import refundRoutes from './routes/refundRoutes.js';

// ...
app.use('/api/refunds', refundRoutes);
```

---

## üîß 3. ƒê√ÅNH GI√Å WEBHOOK SERVER HI·ªÜN T·∫†I

### ‚úÖ Nh·ªØng g√¨ ƒë√£ c√≥:

```javascript
// ‚úÖ ƒê√£ ph√¢n bi·ªát inbound/outbound
const isInbound = parseFloat(amount_in || 0) > 0;
const isOutbound = parseFloat(amount_out || 0) > 0;

// ‚úÖ ƒê√£ c√≥ logic parse HT-BOOK...
if (isOutbound) {
  const match = transaction_content?.match(/HT-BOOK(\d+)-([A-Za-z0-9\-]+)/);
  if (match) {
    const bookingId = parseInt(match[1]);
    const bookingCode = match[2];
    // ‚úÖ G·ªçi notifyBackend("refund", ...)
  }
}

// ‚úÖ ƒê√£ c√≥ h√†m notifyBackend
async function notifyBackend(type, payload) {
  const endpoint = type === "payment"
    ? `${backendUrl}/api/payments/confirm`
    : `${backendUrl}/api/refunds/confirm`;  // ‚úÖ ƒê√∫ng endpoint
  // ...
}
```

### ‚úÖ K·∫æT LU·∫¨N: Webhook server **ƒê√É S·∫¥N S√ÄNG**

Kh√¥ng c·∫ßn ch·ªânh s·ª≠a g√¨ th√™m. Ch·ªâ c·∫ßn:
1. Backend t·∫°o endpoint `/api/refunds/confirm`
2. Webhook server s·∫Ω t·ª± ƒë·ªông g·ªçi khi ph√°t hi·ªán giao d·ªãch ti·ªÅn ra v·ªõi pattern `HT-BOOK...`

---

## üìã 4. CHECKLIST TRI·ªÇN KHAI

### B∆∞·ªõc 1: T·∫°o DB Tables
- [ ] Ch·∫°y SQL t·∫°o b·∫£ng `refund_requests`
- [ ] Ch·∫°y SQL t·∫°o b·∫£ng `user_bank_accounts`
- [ ] T·∫°o indexes

### B∆∞·ªõc 2: T·∫°o Models
- [ ] `backend/src/models/refund_request.js`
- [ ] `backend/src/models/user_bank_account.js`
- [ ] C·∫≠p nh·∫≠t `backend/src/models/index.js` ƒë·ªÉ import 2 models m·ªõi

### B∆∞·ªõc 3: T·∫°o Service Layer
- [ ] `backend/src/services/refundService.js`
  - [ ] `createRefundRequest`
  - [ ] `getRefundRequests`
  - [ ] `generateRefundQR`
  - [ ] `confirmRefund`

### B∆∞·ªõc 4: T·∫°o Controller & Routes
- [ ] `backend/src/controllers/refundController.js`
- [ ] `backend/src/routes/refundRoutes.js`
- [ ] ƒêƒÉng k√Ω route trong `index.js`

### B∆∞·ªõc 5: Frontend (n·∫øu c·∫ßn)
- [ ] Trang "My Tickets" c√≥ n√∫t "Y√™u c·∫ßu ho√†n ti·ªÅn"
- [ ] Modal nh·∫≠p l√Ω do ho√†n ti·ªÅn
- [ ] Admin dashboard ƒë·ªÉ duy·ªát refund requests
- [ ] Hi·ªÉn th·ªã QR refund cho admin

### B∆∞·ªõc 6: Testing
- [ ] Test API `POST /api/refunds` (user t·∫°o request)
- [ ] Test API `GET /api/refunds` (admin xem danh s√°ch)
- [ ] Test API `POST /api/refunds/:id/qr` (sinh QR)
- [ ] Test webhook callback v·ªõi mock payload
- [ ] Test end-to-end: user ‚Üí admin ‚Üí webhook ‚Üí DB update

---

## ‚ö†Ô∏è 5. L∆ØU √ù QUAN TR·ªåNG

### A. B·∫£o m·∫≠t th√¥ng tin STK
- **PH·∫¢I** m√£ h√≥a `UserBankAccounts.account_number` tr∆∞·ªõc khi l∆∞u DB
- D√πng AES-256-GCM v·ªõi key t·ª´ `process.env.BANK_ENCRYPTION_KEY`
- Ch·ªâ decrypt khi c·∫ßn sinh QR

### B. Idempotency webhook
- Ki·ªÉm tra `external_ref` (reference_number) ƒë√£ t·ªìn t·∫°i ch∆∞a
- Tr√°nh x·ª≠ l√Ω tr√πng l·∫∑p khi webhook g·ª≠i l·∫°i

### C. Time validation
- Ki·ªÉm tra `showtime.start_time - now >= 90 ph√∫t`
- S·ª≠ d·ª•ng `SYSUTCDATETIME()` ƒë·ªÉ tr√°nh l·ªói timezone

### D. Transaction handling
- T·∫•t c·∫£ operations ph·∫£i wrap trong transaction
- Rollback n·∫øu c√≥ l·ªói b·∫•t k·ª≥

### E. Admin notification
- Khi user t·∫°o refund request, g·ª≠i email/Slack cho admin
- T√≠ch h·ª£p notification service (optional)

---

## üéØ 6. K·∫æT LU·∫¨N CU·ªêI C√ôNG

### ‚úÖ C√ì TH·ªÇ TRI·ªÇN KHAI ƒê∆Ø·ª¢C 100%

**L√Ω do:**
1. ‚úÖ DB c√≥ ƒë·ªß b·∫£ng core (bookings, payments, users, showtimes)
2. ‚úÖ Backend ƒë√£ c√≥ `refundBooking` logic c∆° b·∫£n
3. ‚úÖ Webhook server ƒë√£ s·∫µn s√†ng x·ª≠ l√Ω outbound + parse HT-BOOK
4. ‚ùå Ch·ªâ c·∫ßn b·ªï sung:
   - 2 b·∫£ng m·ªõi (RefundRequests, UserBankAccounts)
   - Service/Controller/Routes m·ªõi
   - Models m·ªõi

**Th·ªùi gian ∆∞·ªõc t√≠nh:**
- DB setup: 30 ph√∫t
- Code backend: 2-3 gi·ªù
- Testing: 1-2 gi·ªù
- **T·ªïng: ~4-5 gi·ªù** (n·∫øu c√≥ kinh nghi·ªám)

**Kh√≥ khƒÉn duy nh·∫•t:**
- User ph·∫£i nh·∫≠p th√¥ng tin STK tr∆∞·ªõc khi y√™u c·∫ßu refund
- C·∫ßn trang profile ƒë·ªÉ user th√™m/qu·∫£n l√Ω STK

---

## üìû G·ª£i √Ω ti·∫øp theo

N·∫øu b·∫°n mu·ªën, t√¥i c√≥ th·ªÉ:
1. ‚úÖ T·∫°o migration SQL ƒë·ªÉ t·∫°o 2 b·∫£ng m·ªõi
2. ‚úÖ T·∫°o ƒë·∫ßy ƒë·ªß code backend (models, services, controllers, routes)
3. ‚úÖ T·∫°o API docs (Postman collection)
4. ‚úÖ T·∫°o test cases v·ªõi mock data

B·∫°n mu·ªën t√¥i l√†m b∆∞·ªõc n√†o tr∆∞·ªõc? üöÄ
